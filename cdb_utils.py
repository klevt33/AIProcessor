from typing import Optional

from cdb import CDB
from config import Config
from constants import APIPaths, Constants, CosmosLogStatus, Logs
from logger import logger
from utils import generate_uuid, get_current_datetime_cst, get_rental_flag


class CDB_Utils:
    def __init__(self, config: Config, cdb: CDB):
        self.config = config
        self.cdb = cdb

    def prepare_documents_for_ai_jobs(self, request_body, detail_ids):
        """
        Prepares a list of job documents for AI processing.

        Args:
            request (ProcessInvoiceRequest): Request object containing job details.
            detail_ids (List[str]): List of invoice detail IDs to process.

        Returns:
            List[dict]: A list of job documents ready for insertion into Cosmos DB.
        """
        now = get_current_datetime_cst()
        jobs = [
            {
                Logs.ID: "~".join([request_body.id, str(detail_id)]),
                Logs.API_REQUEST_UUID: request_body.api_request_uuid,
                Logs.APP_VERSION: self.config.app_version,
                Logs.REQUEST_DETAILS: {
                    Logs.REQUEST_ID: request_body.id,
                    Logs.CLASSIFY: request_body.classify,
                    Logs.TOTAL_IDS_IN_REQUEST: len(detail_ids),
                    Logs.SYS_NAME: request_body.sys_name,
                },
                Logs.STATUS: CosmosLogStatus.PENDING_lower,
                Logs.CREATED_AT: now,
            }
            for detail_id in detail_ids
        ]
        return jobs

    def prepare_document_for_ai_api_requests(self, request_body, path):
        """
        Prepares a list of job documents for AI processing.

        Args:
            request (ProcessInvoiceRequest): Request object containing job details.
            detail_ids (List[str]): List of invoice detail IDs to process.

        Returns:
            List[dict]: A list of job documents ready for insertion into Cosmos DB.
        """
        now = get_current_datetime_cst()
        document = {
            Logs.ID: generate_uuid(),
            Logs.APP_VERSION: self.config.app_version,
            Logs.PATH: path,
            Logs.REQUEST: request_body,
            Logs.RECEIVED_AT: now,
        }

        # Additional attributes for /v1/process_invoice_details
        if path == APIPaths.PROCESS_INVOICE_DETAILS:
            document[Logs.STATUS] = CosmosLogStatus.PENDING_lower
            document[Logs.STARTED_AT] = None
            document[Logs.COMPLETED_AT] = None
        return document

    async def prepare_document_for_ai_logs(
        self, request_details, response, process_logs, process_output, invoice_details, pre_process_details, post_process_details
    ):
        """
        Prepares a document for AI process logs.

        Args:
            request_details (dict): Details of the request.
            response (Response): Response object from the AI process.
            process_logs (dict): Logs generated during the AI process.
            process_output (dict): Output generated by the AI process.
            invoice_details (InvoiceDetail): Invoice details object.

        Returns:
            dict: A document ready for insertion into the AI logs container.
        """
        ivce_dtl = {
            "IVCE_DTL_UID": invoice_details.IVCE_DTL_UID,
            "IVCE_HDR_ID": invoice_details.IVCE_HDR_ID,
            "IVCE_NUM": invoice_details.IVCE_NUM,
            "ITM_LDSC": invoice_details.ITM_RPA_LDSC,
            "MFR_PRT_NUM": invoice_details.MFR_PRT_NUM,
            "MFR_NM": invoice_details.MFR_NM,
            "AKS_PRT_NUM": invoice_details.AKS_PRT_NUM,
            "UPC_CD": invoice_details.UPC_CD,
            "CLN_MFR_PRT_NUM": invoice_details.CLN_MFR_PRT_NUM,
            "CLN_MFR_NM": invoice_details.CLN_MFR_NM,
            "CLN_MFR_AI_NM": invoice_details.CLN_MFR_AI_NM,
            "CTGY_ID": invoice_details.CTGY_ID,
            "IS_RENTAL": get_rental_flag(invoice_details.RNTL_IND),
            "IVCE_VRFN_IND": invoice_details.IVCE_VRFN_IND,
        }

        return {
            "id": "-".join([str(request_details["id"]), str(invoice_details.IVCE_DTL_UID)]),
            "app_version": self.config.app_version,
            "request_details": request_details,
            "sql_writer": {"status": "pending", "retry_count": 0},
            "invoice_details_from_rpa": ivce_dtl,
            "pre-processing": pre_process_details,
            "process_details": process_logs,
            "post-processing": post_process_details,
            "process_output": process_output,
            "response_details": response.model_dump(),
        }

    async def create_jobs_in_cosmos_queue(self, request_body, detail_ids):
        """
        Creates jobs in Cosmos DB for AI invoice processing.

        Args:
            request_body (dict): The request metadata containing details about the job.
            detail_ids (list): List of invoice detail IDs to be processed.

        Returns:
            str: A message summarizing the outcome of the job creation process, including
                the number of successful jobs, duplicates, and failures.

        Workflow:
            1. Prepare job documents for AI processing using the provided request and detail IDs.
            2. Add the prepared job documents to the Cosmos DB container.
            3. Log the number of successful jobs, duplicates, and failures.
            4. Return a summary message indicating the outcome of the operation.

        Exception Handling:
            - Logs any errors that occur during the job creation process.
            - Returns an error message if the operation fails.

        Notes:
            - Duplicate jobs are identified and skipped during the addition process.
            - Failures are logged and included in the summary message.

        """
        try:
            # Step 1: Prepare job documents for AI processing
            jobs = self.prepare_documents_for_ai_jobs(request_body, detail_ids)

            # Step 2: Add the prepared job documents to the Cosmos DB container
            duplicates, failures = self.cdb.add_items(self.cdb.ai_jobs_container, jobs)

            # Calculate the number of successfully added jobs
            success_jobs = len(jobs) - len(duplicates) - len(failures)
            logger.info(f"Jobs added to cosmos db: {success_jobs}")

            # Step 3: Return a summary message based on the outcome
            if success_jobs == len(jobs):
                return f" {success_jobs} job(s) have been successfully added to AI invoice processing queue."
            else:
                msg = f"{success_jobs} job(s) are success. "
                if len(duplicates) > 0:
                    msg += (
                        f"But there is/are {len(duplicates)} duplicate(s) Duplicates: {[d.split('~')[-1] for d in duplicates]}."
                    )
                if len(failures) > 0:
                    msg += f"There is/are {len(failures)} failure(s). Failures: {list(failures)}"
                return msg

        except Exception as e:
            # Log and return an error message if the operation fails
            logger.error(f"Error occurred while uploading jobs to cosmos db. {str(e)}", exc_info=True)
            return f"Error occurred while adding job(s) to AI invoice processing queue. {str(e)}"

    async def add_api_request_in_cosmos(self, request_body: Optional[dict], path):
        """
        Adds API request to the cosmos container and returns the message and /id
        """
        try:
            # Step 1: Prepare job documents for AI processing
            doc = self.prepare_document_for_ai_api_requests(request_body=request_body, path=path)

            # Step 2: Add the prepared job documents to the Cosmos DB container
            result = self.cdb.add_item(container=self.cdb.ai_api_requests_container, document=doc)

            if result[Constants.STATUS_lower] == Constants.SUCCESS_lower:
                logger.info(f"Request added to cosmos db container. ID: {result["id"]}")
            else:
                logger.info(
                    f"Tried to add request to cosmos db container. ID: {result['id']}, Status:"
                    f" {result[Constants.STATUS_lower]}, Message: {result[Constants.MESSAGE]}"
                )

            return result[Constants.MESSAGE], doc[Logs.ID]

        except Exception as e:
            # Log and return an error message if the operation fails
            logger.error(f"Error occurred while adding request to cosmos db. {str(e)}", exc_info=True)
            return f"Error occurred while adding request to AI API requests. {str(e)}", None

    def get_doc_id_for_request_id(self, request_id: str) -> str:
        column_filter = " c.id "
        where_cond = f" c.request.id = '{request_id}' "
        return self.cdb.get_documents(
            self.cdb.ai_api_requests_container, column_filter=column_filter, where_condition=where_cond
        )[0]["id"]

    def update_request_status(self, request_id: str, status: CosmosLogStatus):
        doc_id = self.get_doc_id_for_request_id(request_id)
        operations = [{"op": "replace", "path": "/id", "value": status}, {"op": "", "path": "", "value": ""}]
        if status == CosmosLogStatus.DONE_lower:
            operations.append({"op": "replace", "path": "completed_at", "value": get_current_datetime_cst()})
        self.cdb.patch_document(self.cdb.ai_api_requests_container, doc_id=doc_id, operations=operations)

    def get_request_id_statuses(self, request_id: list[str]) -> list[CosmosLogStatus]:
        column_filter = " c.request.id, c.status "
        where_condition = f" where c.request.id in ('{"', '".join(request_id)}')"
        return self.cdb.get_documents(
            self.cdb.ai_api_requests_container, column_filter=column_filter, where_condition=where_condition
        )

    def get_request_total_count(self, req_id: str) -> int:
        where_cond = (
            f" c.request_detail.request_id = {req_id} and c.status in ({CosmosLogStatus.PENDING_lower},"
            f" {CosmosLogStatus.QUEUED_lower}) "
        )
        return self.cdb.get_documents_count(self.cdb.ai_jobs_container, where_condition=where_cond)

    def get_processed_jobs_count(self, req_id):
        """
        Returns count of jobs under given request ID that are completed successfully
        """
        count = 0

        try:
            where_condition = f"WHERE c.request_details.request_id = '{req_id}' and c.status = 'done'"

            count = self.cdb.get_documents_count(container=self.cdb.ai_jobs_container, where_condition=where_condition)

        except Exception as e:
            # Log and return an error message if the operation fails
            logger.error(f"Error occurred while fetching processed jobs count from cosmos db. {str(e)}", exc_info=True)

        return count

    def update_api_request_status(self, api_id, status):
        """
        Updates the request status and start/complete time of request in API container
        """
        patch_ops = [{"op": "set", "path": f"/{Logs.STATUS}", "value": status}]

        if status == CosmosLogStatus.PROCESSING_lower:
            patch_ops.append({"op": "set", "path": f"/{Logs.STARTED_AT}", "value": get_current_datetime_cst()})

        elif status == CosmosLogStatus.DONE_lower:
            patch_ops.append({"op": "set", "path": f"/{Logs.COMPLETED_AT}", "value": get_current_datetime_cst()})

        result = self.cdb.patch_document(
            container=self.cdb.ai_api_requests_container, doc_id=api_id, operations=patch_ops, partition_key=api_id
        )
        return result
